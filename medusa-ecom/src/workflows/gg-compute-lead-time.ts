// src/workflows/gg-compute-lead-time.ts
import {
  createWorkflow,
  createStep,
  StepResponse,
  WorkflowResponse,
} from "@medusajs/framework/workflows-sdk";

type GgComputeLeadTimeInput = {
  // left empty for now – we read from env to keep logic off the frontend
};

type GgComputeLeadTimeResult = {
  weeks: number;
  backlog_count: number;
  z: number;
  base: number;
  divisor: number;
};

const ggCountUnfulfilledStep = createStep(
  "gg-count-unfulfilled-orders",
  async (_: unknown, { container }) => {
    // Resolve the order module service generated by Medusa
    const orderModuleService = container.resolve("order") as any;

    // Count orders considered "not fulfilled"
    // You can tweak this filter set to match your exact definition
    const filters = {
      fulfillment_status: ["not_fulfilled", "partially_fulfilled"],
      // status: ["placed"], // uncomment if you only want placed orders
      // canceled_at: null,  // exclude canceled if your schema exposes it
    };

    // Service Factory provides count* methods; if not, fallback to list + metadata
    const count =
      typeof orderModuleService.countOrders === "function"
        ? await orderModuleService.countOrders(filters)
        : await (async () => {
            // fallback – list with take=0 should still return metadata in some setups
            const list = await orderModuleService.listOrders(filters, {
              take: 0,
            });
            // if your list returns [items, count] – adjust here:
            // return list[1]
            return Array.isArray(list) ? 0 : (list?.length ?? 0);
          })();

    return new StepResponse<number>(count);
  },
);

export const ggComputeLeadTimeWorkflow = createWorkflow(
  "gg-compute-lead-time",
  (_input: GgComputeLeadTimeInput) => {
    const backlog = ggCountUnfulfilledStep();

    const result = createStep("gg-calc-weeks", async (count: number) => {
      // Read env to keep knobs on the backend
      const base = Number(process.env.LEAD_TIME_BASE_WEEKS ?? 2);
      const divisor = Number(process.env.LEAD_TIME_DIVISOR ?? 10);
      const rounding = (process.env.LEAD_TIME_ROUNDING ?? "ceil") as
        | "ceil"
        | "floor"
        | "round";
      const max = process.env.LEAD_TIME_MAX_WEEKS
        ? Number(process.env.LEAD_TIME_MAX_WEEKS)
        : undefined;

      // Compute Z = count / divisor with selected rounding
      const raw = divisor > 0 ? count / divisor : 0;
      const z =
        rounding === "floor"
          ? Math.floor(raw)
          : rounding === "round"
            ? Math.round(raw)
            : Math.ceil(raw);

      let weeks = base + z;
      if (typeof max === "number") {
        weeks = Math.min(weeks, max);
      }

      const payload: GgComputeLeadTimeResult = {
        weeks,
        backlog_count: count,
        z,
        base,
        divisor,
      };

      return new StepResponse(payload);
    })(backlog);

    return new WorkflowResponse(result);
  },
);
